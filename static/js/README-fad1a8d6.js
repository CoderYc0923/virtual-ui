import{d as t,m as d,o as e,C as a,g as i,h as n,q as r,b as l,O as o,x as s,F as h,y as c,s as u,l as b,j as E}from"./vue-90884f3d.js";import{_ as g}from"./index-a7ba88c7.js";const f=g(t({__name:"baseInfiniteScroll",setup(t){const c=d([]),u=d(!1),b=d(!1),E=()=>{b.value||(u.value=!0,setTimeout((()=>{for(let t=90;t<180;t++)c.value.push(t);b.value=!0,u.value=!1}),1e3))};return e((()=>{(()=>{for(let t=0;t<90;t++)c.value.push(t)})()})),(t,d)=>{const e=a("vir-infinite-scroll");return i(),n(e,{onReachedTrigger:E,loading:u.value,width:300,height:400},{default:r((()=>[(i(!0),l(h,null,o(c.value,((t,d)=>(i(),l("div",{class:"tab-item h-8 text-center leading-8 shrink-0",key:d},s(t),1)))),128))])),_:1},8,["loading"])}}}),[["__scopeId","data-v-9a16b96b"]]),p=g(t({__name:"customInfiniteScroll",setup(t){const u=d([]),b=d(!1),E=d(!1),g=()=>{E.value||(b.value=!0,setTimeout((()=>{for(let t=90;t<180;t++)u.value.push(t);E.value=!0,b.value=!1}),1e3))};return e((()=>{(()=>{for(let t=0;t<90;t++)u.value.push(t)})()})),(t,d)=>{const e=a("vir-infinite-scroll");return i(),n(e,{onReachedTrigger:g,width:300,height:400,loading:b.value,reachedText:"结束咯！",targetId:"goal-help1"},{loadingIcon:r((()=>[c("我是自定义内容")])),default:r((()=>[(i(!0),l(h,null,o(u.value,((t,d)=>(i(),l("div",{class:"tab-item h-8 text-center leading-8 shrink-0",key:d},s(t),1)))),128))])),_:1},8,["loading"])}}}),[["__scopeId","data-v-c733e739"]]),v={class:"markdown-body"},A=b('<h1 id="infinitescroll-%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8%E5%AE%B9%E5%99%A8" tabindex="-1">InfiniteScroll 无限滚动容器</h1><p>适用于列表场景的无限滚动容器，采用IntersectionObserver方案(<a href="https://caniuse.com/?search=IntersectionObserver">查看兼容性</a>)</p><blockquote><p>Tip<br> 注意：因为采用的是交叉观察器方案，若需要使用多个无限滚动容器，需传入唯一的<code>targetId</code></p></blockquote><h2 id="%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95" tabindex="-1">基础用法</h2><p>通过<code>width``height</code> 来定义横向滚动容器的宽高，并实现简单的分页请求列表</p>',5),m=E("h2",{id:"%E9%80%9A%E8%BF%87%E6%8F%92%E6%A7%BD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8A%E7%BB%93%E6%9D%9F%E6%96%87%E6%A1%88",tabindex:"-1"},"通过插槽自定义加载以及结束文案",-1),B=E("p",null,[c("通过具名插槽"),E("code",null,"loadingIcon"),c("实现自定义加载中显示内容,通过"),E("code",null,"reachedText"),c(" 自定义结束文案")],-1),I=b('<h2 id="infinitescroll-%E5%B1%9E%E6%80%A7" tabindex="-1">InfiniteScroll 属性</h2><table><thead><tr><th>属性</th><th>说明</th><th>类型</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>width</td><td>容器宽</td><td>number、string</td><td>—</td><td>100%</td></tr><tr><td>height</td><td>容器高</td><td>number、string</td><td>—</td><td>100%</td></tr><tr><td>loading</td><td>是否为加载中状态</td><td>boolean</td><td>—</td><td>false</td></tr><tr><td>loading-icon</td><td>自定义加载中图标</td><td>string</td><td>参考icon组件</td><td>Loading</td></tr><tr><td>iconColor</td><td>加载中图标颜色</td><td>string</td><td>—</td><td>black</td></tr><tr><td>reachedText</td><td>结束文案</td><td>string</td><td>—</td><td>没有更多了</td></tr><tr><td>hideReachedText</td><td>是否隐藏结束文案</td><td>boolean</td><td>—</td><td>false</td></tr><tr><td>targetId</td><td>被观察对象唯一ID值</td><td>string</td><td>—</td><td>goal-help</td></tr></tbody></table><h2 id="infinitescroll-%E4%BA%8B%E4%BB%B6" tabindex="-1">InfiniteScroll 事件</h2><table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>reached-trigger</td><td>触底时回调函数</td></tr></tbody></table><h2 id="infinitescroll-%E6%8F%92%E6%A7%BD" tabindex="-1">InfiniteScroll 插槽</h2><table><thead><tr><th>插槽名</th><th>说明</th></tr></thead><tbody><tr><td>—</td><td>插槽自定义内容区只需填入 N 个子元素即可</td></tr><tr><td>loadingIcon</td><td>自定义加载中显示内容</td></tr></tbody></table>',6),x={__name:"README",setup:(t,{expose:d})=>(d({frontmatter:{}}),(t,d)=>{const e=a("show-code");return i(),l("div",v,[A,u(e,{showPath:"infinitescroll/components/baseInfiniteScroll"},{default:r((()=>[u(f)])),_:1}),m,B,u(e,{showPath:"infinitescroll/components/customInfiniteScroll"},{default:r((()=>[u(p)])),_:1}),I])})};export{x as default};
