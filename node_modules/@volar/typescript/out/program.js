"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateProgram = void 0;
function decorateProgram({ createSourceFile }, options, core, program) {
    const _getRootFileNames = program.getRootFileNames.bind(program);
    const _getSyntacticDiagnostics = program.getSyntacticDiagnostics.bind(program);
    const _getSemanticDiagnostics = program.getSemanticDiagnostics.bind(program);
    const _getGlobalDiagnostics = program.getGlobalDiagnostics.bind(program);
    const _emit = program.emit.bind(program);
    // @ts-expect-error
    const _getBindAndCheckDiagnostics = program.getBindAndCheckDiagnostics.bind(program);
    program.getRootFileNames = getRootFileNames;
    program.getSyntacticDiagnostics = getSyntacticDiagnostics;
    program.getSemanticDiagnostics = getSemanticDiagnostics;
    program.getGlobalDiagnostics = getGlobalDiagnostics;
    program.emit = emit;
    // @ts-expect-error
    program.getBindAndCheckDiagnostics = getBindAndCheckDiagnostics;
    // TODO
    function getRootFileNames() {
        return _getRootFileNames().filter(fileName => options.host?.fileExists?.(fileName));
    }
    // for vue-tsc --noEmit --watch
    function getBindAndCheckDiagnostics(sourceFile, cancellationToken) {
        return getSourceFileDiagnosticsWorker(sourceFile, cancellationToken, _getBindAndCheckDiagnostics);
    }
    // for vue-tsc --noEmit
    function getSyntacticDiagnostics(sourceFile, cancellationToken) {
        return getSourceFileDiagnosticsWorker(sourceFile, cancellationToken, _getSyntacticDiagnostics);
    }
    function getSemanticDiagnostics(sourceFile, cancellationToken) {
        return getSourceFileDiagnosticsWorker(sourceFile, cancellationToken, _getSemanticDiagnostics);
    }
    function getSourceFileDiagnosticsWorker(sourceFile, cancellationToken, api) {
        if (sourceFile) {
            const [virtualFile, source] = core.virtualFiles.getVirtualFile(sourceFile.fileName);
            if (virtualFile && source) {
                if (!virtualFile.capabilities.diagnostic)
                    return [];
                const errors = transformDiagnostics(api(sourceFile, cancellationToken) ?? []);
                return errors;
            }
        }
        return transformDiagnostics(api(sourceFile, cancellationToken) ?? []);
    }
    function getGlobalDiagnostics(cancellationToken) {
        return transformDiagnostics(_getGlobalDiagnostics(cancellationToken) ?? []);
    }
    function emit(targetSourceFile, _writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        const scriptResult = _emit(targetSourceFile, options.host?.writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
        return {
            emitSkipped: scriptResult.emitSkipped,
            emittedFiles: scriptResult.emittedFiles,
            diagnostics: transformDiagnostics(scriptResult.diagnostics),
        };
    }
    // transform
    function transformDiagnostics(diagnostics) {
        const result = [];
        for (const diagnostic of diagnostics) {
            if (diagnostic.file !== undefined
                && diagnostic.start !== undefined
                && diagnostic.length !== undefined) {
                const [virtualFile, source] = core.virtualFiles.getVirtualFile(diagnostic.file.fileName);
                if (virtualFile && source) {
                    if (options.host?.fileExists?.(source.fileName) === false)
                        continue;
                    for (const [_, [sourceSnapshot, map]] of core.virtualFiles.getMaps(virtualFile)) {
                        if (sourceSnapshot !== source.snapshot)
                            continue;
                        for (const start of map.toSourceOffsets(diagnostic.start)) {
                            const reportStart = typeof start[1].data.diagnostic === 'object' ? start[1].data.diagnostic.shouldReport() : !!start[1].data.diagnostic;
                            if (!reportStart)
                                continue;
                            for (const end of map.toSourceOffsets(diagnostic.start + diagnostic.length, true)) {
                                const reportEnd = typeof end[1].data.diagnostic === 'object' ? end[1].data.diagnostic.shouldReport() : !!end[1].data.diagnostic;
                                if (!reportEnd)
                                    continue;
                                onMapping(diagnostic, source.fileName, start[0], end[0], source.snapshot.getText(0, source.snapshot.getLength()));
                                break;
                            }
                            break;
                        }
                    }
                }
                else {
                    if (options.host?.fileExists?.(diagnostic.file.fileName) === false)
                        continue;
                    onMapping(diagnostic, diagnostic.file.fileName, diagnostic.start, diagnostic.start + diagnostic.length, diagnostic.file.text);
                }
            }
            else if (diagnostic.file === undefined) {
                result.push(diagnostic);
            }
        }
        return result;
        function onMapping(diagnostic, fileName, start, end, docText) {
            let file = fileName === diagnostic.file?.fileName
                ? diagnostic.file
                : undefined;
            if (!file) {
                if (docText === undefined) {
                    const snapshot = core.host.getScriptSnapshot(fileName);
                    if (snapshot) {
                        docText = snapshot.getText(0, snapshot.getLength());
                    }
                }
                else {
                    file = createSourceFile(fileName, docText, 99, undefined, 7);
                    // fix https://github.com/vuejs/language-tools/issues/2622 for TS 5.0
                    file.originalFileName = fileName;
                    file.path = fileName.toLowerCase();
                    file.resolvedPath = fileName.toLowerCase();
                }
            }
            const newDiagnostic = {
                ...diagnostic,
                file,
                start: start,
                length: end - start,
            };
            const relatedInformation = diagnostic.relatedInformation;
            if (relatedInformation) {
                newDiagnostic.relatedInformation = transformDiagnostics(relatedInformation);
            }
            result.push(newDiagnostic);
        }
    }
}
exports.decorateProgram = decorateProgram;
//# sourceMappingURL=program.js.map